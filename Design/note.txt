=======================================================================

Each ITCH decoder module (e.g. Add, Cancel, Trade) works in speculative, byte-streaming mode, meaning:

From byte 0, the decoder tentatively assumes the message might be its target type (e.g. 'A' for Add Order) and starts parsing bytes immediately.

In parallel, it checks whether the type actually matches its target.

If the type is not a match, it suppresses itself using a suppress_count, which disables parsing for the expected length of that other message.

If the type does match:

It continues parsing the stream byte-by-byte into fields.

At the final expected byte (MSG_LENGTH - 1), it raises a 1-cycle internal_valid pulse.

It also checks the next byte: if it's not the same message type, it will suppress itself again for the next message.

At the end of every message or when suppression is needed, it:

Resets its state, including fields and internal flags.

Optionally starts parsing the new byte if it’s of the correct type.

This architecture allows zero wait cycles between packets and ensures that only the relevant decoder stays active, even in back-to-back or interleaved packet streams.

arbitration logic in pseudo code


module *_decoder (
    input  logic        clk,
    input  logic        rst,
    input  logic [7:0]  byte_in,
    input  logic        valid_in,

    output logic        *_internal_valid,
    output logic        *_packet_invalid,

    // additional parsed outputs here
);

    parameter MSG_TYPE   = 8'hXX;  // ASCII message type letter
    parameter MSG_LENGTH = NN;    // fixed message length

    // ITCH message length lookup for suppression
    function automatic logic [5:0] itch_length(input logic [7:0] msg_type);
        case (msg_type)
            "A": return 36;
            "X": return 23;
            "U": return 27;
            "D": return 9;
            "E": return 30;
            "P": return 44;
            default: return 2;
        endcase
    endfunction

    logic [5:0] suppress_count;
    logic [5:0] byte_index;
    logic       is_*_order;

    wire decoder_enabled = (suppress_count == 0);

    // -----------------------
    // Suppression Controller
    // -----------------------
    always_ff @(posedge clk) begin
        if (rst) begin
            suppress_count <= 0;
        end else if (suppress_count != 0) begin
            suppress_count <= suppress_count - 1;
        end
    end

    // -----------------------
    // Main Decoder FSM
    // -----------------------
    always_ff @(posedge clk) begin
        if (rst) begin
            byte_index         <= 0;
            is_*_order         <= 0;
            *_internal_valid   <= 0;
            *_packet_invalid   <= 0;
            // reset parsed outputs here
        end 
        else if (valid_in && decoder_enabled) begin
            *_internal_valid <= 0;
            *_packet_invalid <= 0;

            if (byte_index == 0) begin
                is_*_order <= (byte_in == MSG_TYPE);
                if (byte_in == MSG_TYPE)
                    byte_index <= 1;
                else begin
                    suppress_count <= itch_length(byte_in) - 2;
                    is_*_order     <= 0;
                    byte_index     <= 0;
                end
            end else begin
                byte_index <= byte_index + 1;
            end

            if (is_*_order) begin
                case (byte_index)
                    // decode fields here
                endcase

                if (byte_index == MSG_LENGTH - 1)
                    *_internal_valid <= 1;
            end

            if (byte_index >= MSG_LENGTH && is_*_order)
                *_packet_invalid <= 1;
        end

        // Defensive invalidation
        if (is_*_order && (
            (valid_in == 0 && byte_index > 0 && byte_index < MSG_LENGTH) ||
            (byte_index >= MSG_LENGTH)
        ))
            *_packet_invalid <= 1;

        // -----------------------
        // Completion and Re-entry
        // -----------------------
        if (byte_index == MSG_LENGTH) begin
            *_internal_valid <= 0;
            *_packet_invalid <= 0;
            // reset parsed outputs here

            if (valid_in && byte_in == MSG_TYPE) begin
                is_*_order <= 1;
                byte_index <= 1;
            end else if (valid_in) begin
                is_*_order     <= 0;
                byte_index     <= 0;
                suppress_count <= itch_length(byte_in) - 2;
            end else begin
                is_*_order <= 0;
                byte_index <= 0;
            end
        end
    end

endmodule



























ITCH Parser Specification (Low-Latency, Speculative Architecture)
=================================================================

Overview:
---------
This module implements a fully speculative, ultra-low-latency ITCH parser
designed for real-time high-frequency trading (HFT) systems on FPGA.
It receives a raw byte stream of ITCH messages, speculatively decodes
them using parallel modules, and outputs structured data suitable for
direct consumption by downstream modules such as order books or trading logic cores.

Architecture Style:
-------------------
Fully speculative parallel decoder architecture.
There is no centralized "header parser" module.

Instead:
- All message-type-specific decoder modules receive the byte stream in parallel.
- On cycle 0 (first byte), each decoder compares the message type.
- If the type matches, that decoder continues parsing the payload.
- Non-matching decoders self-disable after 1 cycle.
- Length validation and message type verification are performed in parallel.
- A watchdog/arbitration unit selects the correct decoder output at the end
  of the message and drives the final output signals.

Decoder Early Exit Behavior:
----------------------------
- On cycle 0, all decoders receive the first byte of the message (byte[0]).
- Each decoder compares the incoming message type (byte_in) to its assigned type.
- If the message type matches, the decoder sets an internal `active` flag and begins parsing.
- If the type does not match, the decoder self-disables immediately on cycle 1.
- In the case of an unsupported or invalid message type (i.e., no decoder matches), all decoders will self-disable on cycle 1.
- No parsed output is produced in that case, and the watchdog will withhold parsed_valid.

Pipeline Behavior:
------------------
Cycle 0:
  - byte[0] (message type) received.
  - All decoders activated speculatively.
  - Length validator starts lookup for expected length.

Cycle 1:
  - byte[1] (length MSB) received.
  - Non-matching decoders self-disable.

Cycle 2:
  - byte[2] (length LSB) received.
  - Length validator compares declared vs expected length.

Cycle 3 to N:
  - Remaining payload bytes streamed into the active decoder.
  - Internal byte counter increments on each valid_in.

Final Cycle (N = packet_length - 1):
  - Last byte received.
  - Length validator confirms match.
  - Watchdog checks decoder outputs.
  - If one decoder asserts internal_valid, its output is selected.

Next Cycle:
  - Output is presented on the parsed data bus.
  - parsed_valid is pulsed for one cycle.

Input Format (Upstream → Parser)
--------------------------------
Description:
  The parser receives a continuous stream of raw ITCH bytes from an upstream
  module (e.g., TCP offload engine, MicroBlaze, or direct MAC).

Signals:
  clk         : input 1-bit     // system clock
  rst         : input 1-bit     // synchronous reset
  byte_in     : input [7:0]     // incoming byte (1 per clock cycle)
  valid_in    : input 1-bit     // high when byte_in is valid

Timing Behavior:
  - Each ITCH message begins with:
      byte[0] : message_type (1 byte)
      byte[1] : length MSB
      byte[2] : length LSB
  - Remaining bytes: payload (length - 3 bytes)
  - One byte per clock, valid when valid_in = 1
  - Parser internally determines message boundaries using length

Assumptions:
  - Byte-aligned input (no framing errors)
  - No backpressure on input; valid_in drives stream timing
  - Data source ensures message alignment

Output Format (Parser → Downstream)
-----------------------------------
Description:
  The parser outputs one fully decoded message per clock cycle,
  presented as a wide, structured bundle of fixed-width fields.
  The downstream consumer (e.g., order book or trading logic)
  receives these messages synchronously.

Signals:
  parsed_valid    : output 1-bit      // high for 1 cycle when parsed_data is valid
  parsed_type     : output [3:0]      // message type ID (see encoding below)
  order_ref       : output [63:0]     // order reference number
  side            : output 1-bit      // 0 = buy, 1 = sell
  shares          : output [31:0]     // number of shares
  price           : output [63:0]     // price (fixed-point format)
  new_order_ref   : output [63:0]     // new order ref for replace messages
  timestamp       : output [31:0]     // ITCH timestamp
  misc_data       : output [63:0]     // optional field (symbol, match ID, etc.)

Message Type Encoding:
  parsed_type = 4'd1 : Add Order ('A')          — 36 bytes
  parsed_type = 4'd2 : Cancel Order ('X')       — 23 bytes
  parsed_type = 4'd3 : Delete Order ('D')       — 19 bytes
  parsed_type = 4'd4 : Replace Order ('U')      — 35 bytes
  parsed_type = 4'd5 : Executed Order ('E')     — 31 bytes
  parsed_type = 4'd6 : Trade ('P')              — 44 bytes
  parsed_type = 4'd15: Unknown / Reserved

Notes:
  - All fields are fixed-width and always driven.
  - Unused fields in a given message type are zeroed.
  - Only one parsed_valid pulse per message.
  - Output should be registered and optionally connected to FIFO or dispatcher.

Decoder Modules to Be Implemented
---------------------------------
  - add_order_decoder         // for 'A', 36 bytes
  - cancel_order_decoder      // for 'X', 23 bytes
  - delete_order_decoder      // for 'D', 19 bytes
  - replace_order_decoder     // for 'U', 35 bytes
  - executed_order_decoder    // for 'E', 31 bytes
  - trade_decoder             // for 'P', 44 bytes

Each decoder is hardcoded with its expected message length and field structure.

Decoder Module Interface (Corrected)
------------------------------------

Inputs:
  clk            : input 1-bit         // clock
  rst            : input 1-bit         // synchronous reset
  byte_in        : input [7:0]         // incoming data byte
  valid_in       : input 1-bit         // high when byte_in is valid

Outputs:
  internal_valid : output 1-bit        // asserted when decoding is complete and valid
  packet_invalid : output 1-bit        // asserted if stream ends early or corrupt
  parsed_data    : output struct       // message-specific parsed fields (see Output Format)

Decoder Behavior:
-----------------
- On cycle 0, when valid_in is high, byte_in is compared against the expected message type.
- If matched, the decoder sets an internal active flag and begins parsing.
- An internal byte counter is incremented for each valid byte.
- If the number of valid cycles is less than expected before end-of-stream, packet_invalid is raised.
- On the last expected byte (based on known message length), decoder asserts internal_valid.
- Only the decoder matching the message type should complete execution; all others exit after cycle 0.

Length Expectations (Based on Message Type)
-------------------------------------------
- 'A'  Add Order                → 36 bytes
- 'X'  Cancel Order             → 23 bytes
- 'D'  Delete Order             → 19 bytes
- 'U'  Replace Order            → 35 bytes
- 'E'  Executed Order           → 31 bytes
- 'P'  Trade                    → 44 bytes

Only these types are supported in the current low-latency hardware parser.
All other message types (e.g., 'F', 'R', 'H', 'Y') are not implemented.


==================================================================================================

1. Latency Hiding
Starting decoding immediately allows the system to perform useful work in parallel with length parsing. 
By the time the valid_flag is asserted, the parsed data is already available and ready for use. 
This avoids delays in downstream logic. 
In contrast, a non-speculative design would wait for the length to be validated before starting the decode, 
introducing extra latency.

2. Constant Throughput and High Clock Utilization
In a non-speculative system, each message introduces an additional delay of several cycles before decoding 
begins. A speculative pipeline, however, keeps all stages active simultaneously—decoding, validating, 
and committing in parallel. This enables consistent throughput of one message per N cycles, 
rather than N plus additional latency.

3. Pipeline Compatibility
Speculative decoding fits well with deep pipelined FPGA architectures. 
Typical pipeline stages include the parser, length validator, commit stage, 
and downstream logic such as an order book or trading engine. Each stage remains fully utilized, 
eliminating pipeline bubbles and ensuring efficient area usage and deterministic timing.

4. Decoder Simplicity
The decoder only concerns itself with field extraction based on message type 
and does not need to track message length. This separation of parsing and validation simplifies decoder logic, 
improves testability, and supports modular development. The validator becomes reusable, 
and the commit stage can be adapted independently.

5. Parallel Early Filtering
Certain decoded fields—such as symbol or quantity—can be routed to early filtering or monitoring logic, 
even before full validation is complete. This allows for prefetching, early routing, or triggering alerts, 
which can reduce overall system latency. If validation later fails, 
the operation can be retracted or discarded without impacting correctness.